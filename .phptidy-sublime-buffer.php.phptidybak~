<?php
if (!defined('BASEPATH')) exit('No direct script access allowed');

Class LinkChecker {
    private static $_ALLOWED_HTTP_STATUS = array("200", "301", "308");
    private $start_time = NULL;
    private $sitemap = array();
    private $checked = array();
    private $unchecked = array();
    private $saved = array();
    private $saved_invalid = array();
    private $job = NULL;
    private $absolute_top_level = "http://www.kent.ac.uk/";
    private $rate_limit = 500000; /* 500000 is .5 seconds */
    private $rate_last = 0;
    private $page_limit = 0; /* 0 for unlimited */
    private $hit_limit = false;
    private $link_check_count = 0;

    public function run($job) {

        if (empty($job)) return;

        // Load CodeIgniter stuff
        $this->load->library('PHPURI');
        $this->load->model('JobStats');
        $this->load->model('Jobs');
        $this->load->model('Page');
        $this->load->model('Link');

        $this->job = $job;
        $this->start_time = microtime(true);

        // set the top level url for reference
        $this->absolute_top_level = $job->url;

        // begin search at top level
        $this->checkLink($this->absolute_top_level);

        // check remaining unchecked links
        while (!empty($this->unchecked)) {
            // page limit check
            if($this->page_limit == 0 || count($this->checked) < $this->page_limit) {
                $url = array_shift($this->unchecked);
                $this->checkLink($url);
                
                $this->saveProgress();
            } else {
                $this->hit_limit = true;
                break;
            }
        }

        $this->job->dateFinished = date("Y-m-d H:i:s");
        $this->Jobs->save($this->job);

        $this->setStats(false);
    }

    public function getSitemap() {
        return $this->sitemap;
    }

    public function getChecked() {
        return $this->checked;
    }

    public function getHitLimit() {
        return $this->hit_limit;
    }

    public function setStats($create = true) {
        $stats = array();
        $stats["checked"] = count($this->checked);
        $stats["valid"] = 0;
        $stats["invalid"] = 0;

        // count the number of valid/invalid pages in sitemap
        foreach($this->sitemap as $url => $page) {
            if($page["status"] == 200) {
                $stats["valid"]++;
            } else {
                $stats["invalid"]++;
            }
        }

        $stats["run_time"] = (float)(microtime(true) - $this->start_time);
        $stats["links_per_minute"] = (60.0 / $stats["run_time"]) * $stats["checked"];

        // calculate percentages
        if ($stats["checked"] > 0) {
            $stats["valid_percent"] = round( ( $stats["valid"] / $stats["checked"] ) * 100 );
            $stats["invalid_percent"] = round( ( $stats["invalid"] / $stats["checked"] ) * 100 );
        } else {
            $stats["valid_percent"] = 100;
            $stats["invalid_percent"] = 0;
        }

        if ($create) {
            JobStats::create_from_array($this->job, $stats);
        } else {
            JobStats::update_from_array($this->job, $stats);
        }
    }

    public function setSiteMap() {
        // Create a mass of pages..
        $data = array();

        // Get the data into an array that works with Codeigniter
        foreach ($this->sitemap as $url => $extra) {
            $data[] = array(
                "jobId" => $this->job->id,
                "url" => $url,
                "internal" => true, // TODO: UNUSED, USE
                "speed" => $extra['time'],
                "http_status" => (int)$extra['status']
            );
        }

        Page::batch_create($data);
    }

    // Save pages to the database
    public function saveProgress() {
        // Create a mass of pages..
        $data = array();

        $check = array_diff_key($this->sitemap, array_flip($this->saved));
        // Get the data into an array that works with Codeigniter
        foreach ($check as $url => $extra) {
            $this->saved[] = $url;
            $data[] = array (
                "jobId" => $this->job->id,
                "url" => $url,
                "internal" => true, // TODO: UNUSED, USE
                "speed" => $extra['time'],
                "http_status" => (int)$extra['status']
            );
        }

        Page::batch_create($data);

        // get invalid links
        $invalid = $this->checkInvalid();
        $newInvalid = array();

        // loop through and check if they need to be saved
        foreach($invalid as $to => $froms) {
            // check if this to already has been saved
            if(!isset($this->saved_invalid[$to])) {
                $this->saved_invalid[$to] = $froms;
                // add data to newInvalid array for each from address
                foreach($this->saved_invalid[$to] as $from) {
                    $newInvalid[] = array(
                        "jobId" => $this->job->id,
                        "from" => Page::find_by_job_and_url($this->job, $from)->id,
                        "to" => Page::find_by_job_and_url($this->job, $to)->id
                    );
                }
            } else {
                // check if this to exists but has new links
                if(count($froms) != count($this->saved_invalid[$to])) {
                    // get urls not currently saved
                    $diff = array_diff($froms, $this->saved_invalid[$to]);
                    // add the new urls to invalid arrays
                    foreach($diff as $from) {
                        $this->saved_invalid[$to][] = $from;
                        $newInvalid[] = array(
                            "jobId" => $this->job->id,
                            "from" => Page::find_by_job_and_url($this->job, $from)->id,
                            "to" => Page::find_by_job_and_url($this->job, $to)->id
                        );
                    }
                }
            }   
        }

        Link::batch_create($newInvalid);
    }

    private function checkInvalid() {
        $invalid = array();
        // find the invalid pages
        foreach($this->sitemap as $url => $page) {
            if($page["status"] != 200) {
                $invalid[$url] = array();
            }
        }

        // find pages that link to them
        foreach($this->sitemap as $url => $page) {
            // only include pages that have links
            if(isset($page["links"])) {
                // check each invalid link to see if it is on the page
                foreach($invalid as $iurl => &$ilink) {
                    if(in_array($iurl, $page["links"])) {
                        $ilink[] = $url;
                    }
                }    
            }
        }

        return $invalid;
    }

    public function setPageLimit($limit) {
        $this->page_limit = $limit;
    }

    public function setRateLimit($limit) {
        $this->rate_limit = $limit;
    }

    private function checkLink($url) {
        if ($this->link_check_count % 20) {
            // Every 20 pages, update the updated time
            $this->job->dateUpdated = date("Y-m-d H:i:s");
            $this->Jobs->save($this->job);
        }
        $this->link_check_count++;


        $skip = false;

        // limit rate of checking
        $delay = $this->rate_limit - (microtime(true) - $this->rate_last);
        if($delay > 0) {
            usleep($this->rate_limit);  
        }
        
        // update last rate check time
        $this->rate_last = microtime(true);

        $ch = curl_init($url);
        // return the content of the page on curl_exec
        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);
        curl_setopt($ch, CURLOPT_TIMEOUT, 6);

        // if this is not a html page only do a HEAD request
        if($url[strlen($url) - 1] != "/" && strpos($url, ".html") === false && strpos($url, ".html") === false) {
            curl_setopt($ch, CURLOPT_NOBODY, true);
            $skip = true;
        }

        $ce = curl_exec($ch);
        // get useful info such as headers
        $ci = curl_getinfo($ch);

        if (curl_errno($ch)) {
            print "CURL Error: " . curl_errno($ch) . "... \n";
            curl_close($ch);
            return; // Not much we can do..
        }

        // close the curl session
        curl_close($ch);

        // mark as checked
        $this->checked[] = $url;

        $links = array();

        // check if url should be skipped
        if(!$skip && in_array($ci["http_code"], self::$_ALLOWED_HTTP_STATUS)) {
            $links = $this->getLinks($ce, $url);

            // remove duplicates
            $links = array_unique($links);
        }

        $map_links = array();

        // check if link has already been checked
        foreach ($links as $u) {
            // check url is within top level
            if (strpos($u, $this->absolute_top_level) !== false) {
                // check if url should be added to unchecked list
                if (!in_array($u, $this->checked) && !in_array($u, $this->unchecked)) {
                    $this->unchecked[] = $u;
                }
                $map_links[] = $u;
            } else {
                // TODO: external link checking
            }
        }

        // add to sitemap
        $this->sitemap[$url] = array("status" => $ci["http_code"], "time" => $ci["total_time"]);
        if (!empty($map_links)) {
            $this->sitemap[$url]["links"] = $map_links;
        }

        $this->setStats($url == $this->absolute_top_level);
    }

    /* get all href links from the source of the page */
    private function getLinks($content, $current_url) {
        $regexp = "<a[\s]+[^>]*?href[\s]?=[\s\"\'](.*?)[\"\'].*?>([^<]+|.*?)?<\/a>";
        if(preg_match_all("/$regexp/si", $content, $matches)) {
            // return the cleaned up urls
            return $this->cleanUrls($matches[1], $current_url);
        }

        return array();
    }

    /* This function accepts an array of urls of any format and returns a list of absolute urls */
    private function cleanUrls($urls, $current_url) {
        $cleaned = array();

        foreach($urls as $url) {
            // remove index.html from end of urls
            $url = str_replace("index.html", "", $url);
            
            // throw away urls we don't want
            if(strpos($url, "#") === 0 || strpos($url, "mailto:") === 0 || strpos($url, "javascript:") === 0 || strpos($url, "#CalendarSnippetFull2") !== false) {
                // do nothing
            } elseif(strpos($url, "http://") === 0 || strpos($url, "https://") === 0) {
                // put absolute links with scheme straight into the array
                $cleaned[] = $url;
            } else {
                // relative link
                $cleaned[] = PHPURI::parse($current_url)->join($url);
            }
        }

        return $cleaned;
    }


    /**
     * __get
     *
     * Allows models to access CI's loaded classes using the same
     * syntax as controllers.
     *
     * @param   string
     * @access private
     */
    function __get($key)
    {
        $CI =& get_instance();
        return $CI->$key;
    }
}
